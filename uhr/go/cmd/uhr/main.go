package main

// #cgo CFLAGS: -DUHR_CGO -I../../../include
// #include <UnityHttpRequests.h>
import "C"

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"time"
	"unicode/utf16"
	"unsafe"
)

const (
	methodGet  = "GET"
	methodPost = "POST"
)

var methodToString = map[C.int32_t]string{
	C.UHR_METHOD_GET:  "GET",
	C.UHR_METHOD_POST: "POST",
}

// This holds a reference to the HTTPContext structures which have been
// returned to C-land as a pointer.  It keeps them from being collected prematurely.
var httpContexts = make(map[C.UHR_HttpContext]*HTTPContext, 4)

// The last error message generated by a failed api call
var lastError = make([]uint16, 0, 128)

var scratchString = make([]uint16, 0, 128)

// RequestID is an identifier for an http request
type RequestID int32

// Result is for tracking the result of an http request
type Result struct {
	rid  int
	err  error
	resp *http.Response
}

// HeaderStorage is the backing memory of a header that can be referenced by UHR_StringRefs
type HeaderStorage struct {
	key   []uint16
	value []uint16
}

// ResultStorage is the backing memory for a response that can be referenced by a UHR_Response
type ResultStorage struct {
	headers    []HeaderStorage
	headerRefs []C.UHR_Header
	body       []byte
}

// HTTPContext manages a set of requests and responses.
type HTTPContext struct {
	client        *http.Client
	cancelFuncs   map[int]context.CancelFunc // Keyed by request id
	resultStorage map[int]*ResultStorage     // Keyed by request id
	results       chan Result
	nextRequestID int
}

func setLastError(err string) {
	lastError = utf16.Encode([]rune(err))
}

func stringRefToString(sr C.UHR_StringRef) string {
	charactersSlice := (*[1 << 30]uint16)(unsafe.Pointer(sr.characters))[:int(sr.length)]
	scratchString = append(scratchString[:0], charactersSlice...)
	return string(utf16.Decode(scratchString[:sr.length]))
}

func newResultStorage(body []byte, headers http.Header) *ResultStorage {
	storage := &ResultStorage{
		headers:    make([]HeaderStorage, 0, len(headers)),
		headerRefs: make([]C.UHR_Header, 0, len(headers)),
		body:       body,
	}
	for k, v := range headers {
		if len(v) > 0 {
			// NOTE: We don't support multiple headers with the same name.
			storage.headers = append(storage.headers, HeaderStorage{
				key:   utf16.Encode([]rune(k)),
				value: utf16.Encode([]rune(v[0])),
			})
		}
	}
	for _, header := range storage.headers {
		storage.headerRefs = append(storage.headerRefs, C.UHR_Header{
			name: C.UHR_StringRef{
				characters: (*C.uint16_t)(unsafe.Pointer(&header.key[0])),
				length:     C.int32_t(len(header.key)),
			},
			value: C.UHR_StringRef{
				characters: (*C.uint16_t)(unsafe.Pointer(&header.value[0])),
				length:     C.int32_t(len(header.value)),
			},
		})
	}
	return storage
}

// UHR_GetLastError gets a message describing the latest error
//export UHR_GetLastError
func UHR_GetLastError(errorOut *C.UHR_StringRef) {
	errorOut.characters = (*C.uint16_t)(unsafe.Pointer(&lastError[0]))
	errorOut.length = C.int32_t(len(lastError))
}

// UHR_CreateHTTPContext creates an HttpContext.
// A owns all the resources, and manages the http request requests.
// Returns:  A valid handle, or UHRHTTP_CONTEXT_INVALID if an error occurred.
//   Use UHRGetLastError to get the error message.
//export UHR_CreateHTTPContext
func UHR_CreateHTTPContext() C.UHR_HttpContext {
	httpContext := &HTTPContext{
		client: &http.Client{
			Transport: &http.Transport{
				MaxIdleConns:       10,
				IdleConnTimeout:    30 * time.Second,
				DisableCompression: true,
			},
		},
		cancelFuncs:   make(map[int]context.CancelFunc, 16),
		resultStorage: make(map[int]*ResultStorage, 16),
		results:       make(chan Result, 16),
		nextRequestID: 1,
	}
	opaqueHandle := (C.UHR_HttpContext)(uintptr(unsafe.Pointer(httpContext)))
	httpContexts[opaqueHandle] = httpContext
	return opaqueHandle
}

// UHR_DestroyHTTPContext frees an HttpContext, and any requests that it is managing.
//export UHR_DestroyHTTPContext
func UHR_DestroyHTTPContext(httpContextHandle C.UHR_HttpContext) {
	httpContext, ok := httpContexts[httpContextHandle]
	if !ok {
		return
	}
	close(httpContext.results)
	for _, cancel := range httpContext.cancelFuncs {
		cancel()
	}
	httpContext.client.CloseIdleConnections()
	delete(httpContexts, httpContextHandle)
}

// UHR_CreateRequest starts a new request.
// Returns:  The request id of the new request, or UHR_REQUEST_ID_INVALID if an error occurred.
//   Use UHRGetLastError to get the error message.
//export UHR_CreateRequest
func UHR_CreateRequest(
	httpContextHandle C.UHR_HttpContext,
	url C.UHR_StringRef,
	method C.int32_t,
	headers *C.UHR_Header,
	headersCount C.int32_t,
	body *C.char,
	bodyLength C.int32_t,
) C.UHR_RequestId {
	httpContext, ok := httpContexts[httpContextHandle]
	if !ok {
		setLastError("Invalid HTTPContext handle")
		return C.UHR_REQUEST_ID_INVALID
	}

	methodStr, ok := methodToString[method]
	if !ok {
		setLastError("Invalid method")
		return C.UHR_REQUEST_ID_INVALID
	}

	var bodyReader io.Reader
	if body != nil && bodyLength > 0 {
		buf := make([]byte, int(bodyLength))
		copy(buf, (*[1 << 30]byte)(unsafe.Pointer(body))[:int(bodyLength)])
		bodyReader = bytes.NewBuffer(buf)
	}

	ctx, cancel := context.WithCancel(context.Background())
	req, err := http.NewRequestWithContext(ctx, methodStr, stringRefToString(url), bodyReader)
	if err != nil {
		cancel()
		setLastError(fmt.Sprintf("Failed to create request: %s", err))
		return C.UHR_REQUEST_ID_INVALID
	}

	if headers != nil && headersCount > 0 {
		headerRefs := (*[1 << 30]C.UHR_Header)(unsafe.Pointer(headers))[:int(headersCount)]
		for _, header := range headerRefs {
			req.Header.Add(stringRefToString(header.name), stringRefToString(header.value))
		}
	}

	rid := httpContext.nextRequestID

	// Advance rid, handle wraparound
	httpContext.nextRequestID++
	if httpContext.nextRequestID <= 0 {
		httpContext.nextRequestID = 1
	}

	httpContext.cancelFuncs[rid] = cancel

	go func() {
		resp, err := httpContext.client.Do(req)
		httpContext.results <- Result{
			rid:  rid,
			resp: resp,
			err:  err,
		}
	}()

	return C.UHR_RequestId(rid)
}

// UHR_Update polls for finished requests.
// Returns: number of responses written to output array, or -1 in the case that the entire operation failed.
//   Use UHRGetLastError to get the error message.
//   Individual requests may also fail:
//      - In the case of a network error, http_status for that response will be -1.
//      - In the case of a failure to read the response body, http_status for that response will be -1.
//		- In the case of an HTTP error, http_status for that response will reflect the HTTP error code.
//export UHR_Update
func UHR_Update(httpContextHandle C.UHR_HttpContext, responsesOut *C.UHR_Response, responsesCapacity C.int32_t) C.int32_t {
	httpContext, ok := httpContexts[httpContextHandle]
	if !ok {
		setLastError("Invalid HTTPContext handle")
		return -1
	}

	resultCount := 0
	responsesOutSlice := (*[1 << 30]C.UHR_Response)(unsafe.Pointer(responsesOut))[:int(responsesCapacity)]

ForLoop:
	for ; resultCount < int(responsesCapacity); resultCount++ {
		select {
		case res := <-httpContext.results:
			if _, ok := httpContext.cancelFuncs[res.rid]; !ok {
				// Already cancelled
				continue ForLoop
			}

			httpStatus := C.int32_t(res.resp.StatusCode)

			var body []byte
			if res.err != nil {
				httpStatus = C.int32_t(-1)
				body = []byte(res.err.Error())
			} else {
				// Use the content length if it's non-negative
				// Otherwise, start with an empty slice and let it grow.
				var capacity = res.resp.ContentLength
				if capacity < 0 {
					capacity = 0
				}
				bodyBuffer := bytes.NewBuffer(make([]byte, 0, capacity))
				if _, err := io.Copy(bodyBuffer, res.resp.Body); err != nil {
					httpStatus = C.int32_t(-1)
					body = []byte(err.Error())
				} else {
					body = bodyBuffer.Bytes()
				}
			}

			storage := newResultStorage(body, res.resp.Header)
			httpContext.resultStorage[res.rid] = storage

			responsesOutSlice[resultCount] = C.UHR_Response{
				request_id:             C.int32_t(res.rid),
				http_status:            httpStatus,
				response_headers:       &storage.headerRefs[0],
				response_headers_count: C.int32_t(len(storage.headerRefs)),
				response_body:          (*C.char)(unsafe.Pointer(&storage.body[0])),
				response_body_length:   C.int32_t(len(storage.body)),
			}
		default:
			break ForLoop
		}
	}

	return C.int32_t(resultCount)
}

// UHR_DestroyRequests frees memory associated with the specified request ids.
// Every request that is created must eventually be destroyed.
// However, destroying the httpContext is sufficient to also destroy all
// the requests it manages.
//
// Returns: Zero on success, or -1 on failure.
//   Use UHRGetLastError to get the error message.
//export UHR_DestroyRequests
func UHR_DestroyRequests(httpContextHandle C.UHR_HttpContext, requestIDs *C.UHR_RequestId, requestIDsCount C.int32_t) C.int32_t {
	httpContext, ok := httpContexts[httpContextHandle]
	if !ok {
		setLastError("Invalid HTTPContext handle")
		return -1
	}
	requestIDsSlice := (*[1 << 30]C.int32_t)(unsafe.Pointer(requestIDs))[:int(requestIDsCount)]
	for _, rid := range requestIDsSlice {
		if cancel, ok := httpContext.cancelFuncs[int(rid)]; ok {
			cancel()
			delete(httpContext.cancelFuncs, int(rid))
			delete(httpContext.resultStorage, int(rid))
		}
	}
	return 0
}

func main() {}
